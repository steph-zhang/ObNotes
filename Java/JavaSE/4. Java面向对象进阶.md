# 4.1 static静态关键字

- static是**静态**的意思，可以修饰成员变量和成员方法。
- static修饰成员变量表示该成员变量**在内存中只存储一份**，可以被**共享访问、修改**

## 4.1.1 静态成员

### 静态成员变量
- 由static修饰，属于类，内存中加载一次。
- 常表示在线人数信息等需要被共享的信息，一般会用public修饰
- 同一个类访问静态成员变量，可以省略类名

```java
	public class User{
		public static String onlineNum = 0;
	}
```

访问方式（推荐）：类名.静态成员变量名。

### 静态成员方法
- 由static修饰，属于类，建议用类名访问
- 同一个类中，访问静态方法，类名可以省略不写
-  如果该方法是以执行一个**共用功能**为目的，则可以声明成静态方法

### static访问注意事项
- **静态方法只能访问静态成员**，不可以直接访问实例成员
- 实例方法可以访问静态成员，也可以访问实例成员
- **静态方法中不可以使用this**

## 4.1.2 static应用：工具类

- **类中都是一些静态方法**，每个方法都是以完成一个公用的功能为目的。这个类用来给系统开发人员共同使用。调用比实例方法更加方便、更节约内存。
- 由于工具类都是静态方法，直接用类名访问即可。因此，工具类无需创建对象，建议**将工具类的构造器私有**。


## 4.1.3 static应用：代码块

- 代码块是类的组成成分之一，定义在类中方法外。
- 在Java类下，使用{}括起来的代码被称为代码块。

### 静态代码块
格式：
`static{}`

特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次。

使用场景：在**类加载的时候**做一些**静态数据初始化**的操作，以便后续使用。

### 构造代码块
格式：
`{}`

特点：每次**创建对象**，调用构造器执行时，都会执行该代码块，并且**在构造器执行前执行**。

使用场景：初始化实例资源。

## 4.1.4 static应用：单例模式

- 可以保证系统中，应用该模式的这个类永远只有一个实例，即：**一个类永远只能创建一个对象**

### 饿汉单例
- 在用类获取对象的时候，对象已经提前为你创建好了。
- 通过**静态成员变量**访问。

设计步骤：
```java
//定义一个单例类
	public class SingleInstance{
		//定义一个静态变量存储一个对象即可
		//属于类，与类一起加载一次
		public static SingleInstance instance = new SingleInstace();

		//单例必须私有构造器
		private SingleInstance(){}
	}
```

### 懒汉单例
- 在真正需要该对象的时候，才去创建一个对象。
- 通过**静态成员方法**访问。

设计步骤：
```java
//定义一个单例类
	public class SingleInstance{
		//定义一个静态变量存储一个对象即可
		//属于类，与类一起加载一次
		public static SingleInstance instance;

		//单例必须私有构造器
		private SingleInstance(){}

		//必须提供一个方法返回一个单例对象
		public static SingleInstance getInstance(){
			if(instance == null){
				instance = new SingleInstance();
			}
			return instance;
		}
	}
```


---
# 4.2 继承

- Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起父子关系。
- 当子类继承父类后，就可以直接使用父类**公共**的属性和方法了。
![[Pasted image 20221029164834.png]]

## 4.2.1 继承的设计

> 子类们**相同特征放在父类中**定义，子类**独有的属性和行为定义在子类中**。

格式：
`class 子类 extends 父类{}`

### 继承内存原理
![[Pasted image 20221029165351.png | 500]]

## 4.2.2 继承的特点

1. 子类可以继承父类的属性和行为，但是子类**不能继承父类的构造器**
	- 子类可以继承父类的私有成员，只是**不能直接访问**
2. Java是单继承模式，一个类只能继承一个直接父类
3. Java**不支持多继承**，但是**支持多层继承**
	- 多层继承时会**就近调用**
4. Java中所有的类都是Object类的子类

### 就近原则

>在子类方法中访问成员（成员变量、成员方法）满足：**就近原则**
- 现在子类局部范围内找
- 然后子类成员范围找
- 然后父类成员范围找，如果父类范围还没有找到则报错

> 如果子父类中，出现了重名的成员，会优先使用子类的，此时如果一定要在子类中使用父类的怎么办？
- 可以通过**super**关键字

## 4.2.3 方法重写

- 在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。

**注意** 
>- 重写方法的名称、形参列表必须与被重写方法的名称、形参列表一致。
>- 父类的私有方法不能被重写
>- 子类重写父类方法时。访问权限必须**大于等于**父类（缺省<protected<public）
>- 子类不能重写父类的静态方法

### @Override重写注解
- @Override是放在重写后的方法上，作为重写是否正确的校验注解

## 4.2.4 构造器特点

- 子类中所有的构造器会默认**先执行父类无参构造器**，再执行自己
- 子类构造器的第一行语句默认都是：`super();`  不写也存在

### 子类调用父类的有参数构造器
- 子类构造器中可以通过super(···)，手动调用父类的有参构造器。

---
# 4.3 包和权限

## 4.3.1 包
- 相同包下的类可以直接访问，不同包下的类必须导包才可以使用。
- 如果这个类中使用不同包下的相同类，此时只能导入一个类的包，另一个类需要使用全名访问。

建包格式：
`package 包名；`

导包格式：
`import 包名.类名;`


## 4.3.2 权限修饰符

- 权限修饰符：是用来控制一个成员能够被访问的范围。
- 可以修饰成员变量，方法，构造器，内部类。

>**private < 缺省 < protected < public**

![[Pasted image 20221029175603.png]]

---
# 4.4 final关键字和常量

## 4.4.1 final关键字
- 可以修饰类、方法、变量
- 修饰类：表明该类是最终类，不能被继承
- 修饰方法：表明该类是最终方法，不能被重写
- 修饰变量：表示该变量第一次赋值后，不能再次被赋值，**常量一定要初始化**

 **final修饰变量的注意**
 - final修饰的变量是基本数据类型，那么变量存储的**数据值**不能发生改变。
 - final修饰的变量是引用数据类型，那么变量存储的**地址值**不能发生改变，但是地址指向的对象内容是可以发生变化的。


## 4.4.2 常量

- 常量是使用了**public static final**修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。
- 可以用作系统的配置信息，方便程序的维护，同时也能提高可读性。

常量命名规范：英文字母全部大写，多个单词用下划线连接

>常量的执行原理：
>- 在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量。
>- 这样做的好处是：让使用常量的程序的执行性能与直接使用字面量是一样的。

### 常量做信息标志和分类

---
# 4.5 枚举

- 枚举是Java中的一种特殊**类**。
- 枚举的作用是为了做信息的**标志和分类**。

基本格式：
```java
	修饰符 enum 枚举名称{
		···
	}

	public enum Season{
			SPRING, SUMMER, FALL, WINTER;
	}
```

反编译：
![[Pasted image 20221030152211.png]]

---
# 4.6 抽象

## 4.6.1 抽象的基本概念

- 在Java中**abstract**是抽象的意思，可以修饰类、成员方法。

```java
	//一个类中如果有抽象方法，那么这个类必须声明成抽象类；
	 public abstract class Animal{
		 //抽象方法只能有方法声明，不能有方法体；
		 public abstract void run();
	 }
```

## 4.6.2 抽象的使用场景

- 抽象类可以理解成不完整的设计图，一般作为父类，让子类来继承。
- 当父类子类一定要完成某些行为，但是每个子类该行为的实现又不同，父类就将该方法定义成抽象方法，具体实现交给子类完成。
- **一个类如果继承了抽象类，那么这个类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。**

## 4.6.2 抽象类的特征和注意事项

- 抽象类中不一定有抽象方法，有抽象方法的一定是抽象类。
- 抽象类中可以有非抽象方法。
- 不能用**abstract**修饰变量、代码块和构造器。
- **final**和**abstract**是互斥关系。

最重要的特征：**失去了创建对象的能力**

## 4.6.3 抽象类应用：模板方法模式

- 使用场景：当系统中出现同一个功能多处在开发，而该功能中大部分代码是一样的。

### 模板方法模式实现模式
- 把功能定义成一个所谓的模板方法。放在抽象类中，模板方法中只定义通用且能确定的代码。
- 模板方法中不能确定的功能定义成抽象方法让具体子类去实现。

```java
	public abstract class template{
		//模板方法，建议用final修饰
		public final void general(){
			//相同的代码
			···
			//不同的代码调用抽象方法
			specific();
			//相同的代码
			···
		}

		public abstract void specific();
	}
```

>模板方法建议用final修饰更专业，不希望子类重写

---
# 4.7 接口

## 4.7.1 接口的定义和特点

格式：
```java
	public interface 接口名{
		//常量 public static final
		//抽象方法
	}
```

- 接口是一种**规范**，规范一定是公开的。
- 代码层面：**public static final**和**public abstract**可以不写

## 4.7.2 接口的实现

- 接口是用来被实现（implements）的。
- 接口可以**多实现**，可以**多继承**。
- 一个类实现接口，必须重写完接口的全部抽象方法，否则这个类需要定义成抽象类。

格式：
```java
	//接口可以多实现
	public class 类名 implements 接口1, 接口2, ···{
		重写接口的抽象类
	}

	//接口可以多继承
	public interface 接口1 extends 接口2, 接口3, ···{

	}
```

## 4.7.3 JDK8接口新增方法

>允许接口中直接定义带有方法体的方法。

第一种：默认方法
- 类似之前写的普通实例方法：必须用**default**修饰。
- 默认会public修饰。需要**用接口的实现类来调用**。
```java
	default void fun(){
		方法体;
	}
```

第二种：静态方法
- 默认会public修饰，必须用**static**修饰。
- 接口的静态方法必须**用本身的接口名来调用**。
```java
	static void fun(){
		方法体;
	}
```

第三种：私有方法
- 就是私有的实例方法，必须用**private**修饰。
- 只能在本类中**被其他的默认方法或者私有方法访问**。
```java
	private void fun(){
		方法体;
	}
```

## 4.7.4 接口的注意事项

- 接口不能创建对象。
- 一个类实现多个接口，多个接口中重名的静态方法不冲突。
- 一个类继承了父类，同时又实现了接口，父类和接口中有同名方法，默认用父类的。
- 一个类实现了多个接口，多个接口中存在同名的默认方法冲突，这个类需要重写该方法。
- 一个接口继承多个接口，如果多个接口中存在规范冲突则不能多继承。

--- 
# 4.8 多态

- 同类型的对象，执行同一个**行为**，会表现出不同的行为特征。

## 4.8.1 多态的常见形式：
```java
	父类类型 对象名称 = new 子类构造器;
	接口 对象名称 = new 实现类构造器;
```

![[Pasted image 20221030163850.png | 500]]

优势：
- 在多态形式下，右边对象可以实现解耦合，便于拓展和维护。
- 在定义方法的时候，使用父类作为参数，该方法就能接受该父类的一切子类对象。

问题：
- 多态下不能调用子类的独有功能。

## 4.8.2多态下的数据类型转换

自动类型转换（从子到父）：子类对象赋值给父类类型的变量。

强制类型转换（从父到子）：
- 格式：`子类 对象变量 = (子类) 父类变量;`
- 可以解决多态的劣势，可以调用子类独有的功能。
```java
	Animal a = new Chicken();
	Chicken c = (Chicken) a;
	c.layEggs();
```

>如果转型后的类型和对象真实类型不是同一种类型，那么在转换的时候就会出现**ClassCastException(类型转换异常)**。
>Java建议在强制类型转换前使用**instanceof**判断当前对象的真实类型。

> 格式：`变量名 instanceof 真实类型`
> 判断关键字左边的变量指向的对象的真实类型，是否是右边的类型或者是其子类型，是则返回true，反之返回false。


---
# 4.9 内部类

- 内部类就是定义在一个类里面的类，里面的类可以理解成寄生，外面的类可以理解成宿主。

基本格式：
```java
	public class People{
		//内部类
		public class Heart{
		
		}
	}
```

>内部类的使用场景及作用：
- 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又**只为外部事物服务**，那么整个内部的完整结构可以选择使用内部类。
- 内部类通常可以方便访问外部类的成员，包括私有的成员。
- 内部类提供了更好的封装性，内部类本身就可以用private proteted等修饰，封装就可以做更多控制。

静态内部类：
![[Pasted image 20221030171046.png]]

成员内部类：
![[Pasted image 20221030171305.png]]

**匿名内部类**

- 本质上是一个没有名字的局部内部类，定义在方法中、代码块中等。
- 匿名内部类写出来就会产生一个匿名内部类的对象。
- 作用是方便创建子类对象，简化代码编写。

格式：
```java
	new 类|抽象类名|接口名(){
		重写方法;
	}

	Employee a = new Employee(){
		public void work(){
			方法体;
		}
	}

	a.work();
```

